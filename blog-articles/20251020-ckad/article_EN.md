# CKAD Preparation — Build a container image

In this article we'll see how to build a container for an API service that exposes a health status and the software version.

The version is read from a metadata.json file which, in a real scenario, might be generated by the CI pipeline — for example using GitVersion — which regenerates builds on releases, merges to develop, etc.

The project we will create will have the following structure:

```text
src/
├── app/
│   ├── main.py
│   └── metadata.json
├── pyproject.toml
└── Dockerfile
```

## Prerequisites

For this exercise you will need Python v3.12 (or newer) and Docker v28 (or newer) to build the container image.

On Windows you can download and install Python from the official releases page: [Download Python for Windows](https://www.python.org/downloads/windows/).

On Linux, if you use apt, you can proceed as follows:

```bash
sudo apt update
sudo apt install python3
```

If you use yum as package manager, you can do the following:

```bash
sudo yum update -y
sudo yum install -y yum-utils
sudo yum install -y python3
```

Alternatively, if you are adventurous, you can install by compiling the source:

```bash
sudo apt install build-essential zlib1g-dev libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev libsqlite3-dev libbz2-dev liblzma-dev
wget https://www.python.org/ftp/python/3.12.11/Python-3.12.11.tgz
tar -zxvf Python-3.12.11.tgz
cd Python-3.12.11/
./configure --enable-optimizations
make -j "$(nproc)"
sudo make altinstall
sudo ln -s /usr/local/bin/python3.12 /usr/local/bin/python

wget https://bootstrap.pypa.io/get-pip.py
python get-pip.py
sudo ln -s /usr/local/bin/pip3.12 /usr/local/bin/pip
```

Finally, we will attempt to publish the image to a Kubernetes cluster. You can use Kubernetes from Docker Desktop, Minikube, or a temporary environment from [KillerCoda Playgrounds](https://killercoda.com/playgrounds).

## How to Get the Resources

All the manifests and examples mentioned in this post are available in the following repository:

```bash
git clone https://github.com/SupaaHiro/schwifty-lab.git
cd schwifty-lab/blog-articles/20251020-ckad
```

## Project initialization

As package manager we will use uv instead of pip.

```bash
pip install uv
uv --version
```

Initialize the project:

```bash
mkdir src && cd src
mkdir app
uv init
uv add fastapi uvicorn
uv lock
```

For metadata we don't have a CI pipeline that injects real metadata, so let's create a simple placeholder:

```json
{
  "version": "1.0.0",
  "build": "local-dev",
  "commit": "0000000"
}
```

Save it to src/app/metadata.json. In a scenario with CI pipelines, this file would be automatically replaced by GitVersion or by a job that writes the correct versioning into the container build context.

## API service sources

These are the sources of our API service that we will run inside a container:

```python
from fastapi import FastAPI
import json
import uvicorn

app = FastAPI()

def load_metadata():
    try:
        with open("metadata.json", "r") as f:
            return json.load(f)
    except FileNotFoundError:
        return {"version": "unknown", "build": "n/a", "commit": "n/a"}

@app.get("/health")
async def health():
    return {"status": "ok"}

@app.get("/version")
async def version():
    return load_metadata()

if __name__ == "__main__":
    uvicorn.run("app:app", port=8000, reload=True)
```

Save it to src/app/main.py.

## Test running the API service

Enable the virtual environment.

On Linux:
```bash
source .venv/bin/activate
which python
```

On Windows:
```bash
.venv\Scripts\activate.bat
where python
```

Try launching it manually to see if it works:

```bash
uv run uvicorn app.main:app --reload
```

You should see output similar to:

```bash
INFO:     Will watch for changes in these directories: ['C:\\repos\\github\\schwifty-lab\\blog-articles\\20251020-ckad\\src']
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO:     Started reloader process [26020] using StatReload
INFO:     Started server process [11200]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
```

Try contacting one of the two endpoints exposed by the service, for example /health:

```bash
curl -svk http://127.0.0.1:8000/health
```

You should see output similar to:

```bash
*   Trying 127.0.0.1:8000...
* Connected to 127.0.0.1 (127.0.0.1) port 8000
* using HTTP/1.x
> GET /health HTTP/1.1
> Host: 127.0.0.1:8000
> User-Agent: curl/8.14.1
> Accept: */*
>
< HTTP/1.1 200 OK
< date: Sun, 19 Oct 2025 18:24:22 GMT
< server: uvicorn
< content-length: 15
< content-type: application/json
<
{"status":"ok"}* Connection #0 to host 127.0.0.1 left intact
```

# Build the container image

Now we need to create the Dockerfile, which is a text file that contains a series of instructions used by Docker to build an image.

```dockerfile
FROM python:3.12-slim
WORKDIR /app

# Install uv
RUN python -m pip install --no-cache-dir uv

# Copy project definition and lock file
COPY pyproject.toml uv.lock ./
RUN python -m uv sync --no-dev

# Copy application
COPY app/ .

# Create non-root user
RUN useradd -m appuser
USER appuser

EXPOSE 5000

# Default environment (can be overridden)
ENV UVICORN_PORT=5000

# Start API inside uv virtual environment
CMD ["uv", "run", "uvicorn", "main:app", "--host", "0.0.0.0", "--port", "5000"]
```

Tip: A container image is an executable, immutable package that contains everything needed to run an application consistently on any system.

Build the container image:

```bash
docker build -t fastapi:v1 .
```

Run it to verify it works:

```bash
docker run -it --rm -p 5000:5000 fastapi:v1
```

Try contacting one of the two endpoints exposed by the service, for example /version:

```bash
curl -svk http://127.0.0.1:5000/version
```

You should see output similar to:

```bash
*   Trying 127.0.0.1:5000...
* Connected to 127.0.0.1 (127.0.0.1) port 5000
* using HTTP/1.x
> GET /version HTTP/1.1
> Host: 127.0.0.1:5000
> User-Agent: curl/8.14.1
> Accept: */*
>
< HTTP/1.1 200 OK
< date: Sun, 19 Oct 2025 18:43:43 GMT
< server: uvicorn
< content-length: 58
< content-type: application/json
<
{"version":"1.0.0","build":"local-dev","commit":"0000000"}* Connection #0 to host 127.0.0.1 left intact
```

## Publishing to Kubernetes

Now that we have an image that builds correctly, we want to try deploying it to Kubernetes. To deploy it to a cluster that does not run locally, we must first publish it to a Container Registry — a repository for images. If you haven't already, create an account on [Docker Hub](https://hub.docker.com) and then log in:

```bash
docker login
```

At this point you can tag your image as "your-account/image-name:tag":

```bash
docker tag fastapi:v1 <your-docker-account>/fastapi:v1
docker push <your-docker-account>/fastapi:v1
```

We will deploy our container as a Deployment:

```yaml
# manifests/01-fastapi.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: fastapi
spec:
  replicas: 1
  selector:
    matchLabels:
      app: fastapi
  template:
    metadata:
      labels:
        app: fastapi
    spec:
      containers:
      - name: fastapi
        image: <your-docker-account>/fastapi:v1
        ports:
        - containerPort: 5000
---
apiVersion: v1
kind: Service
metadata:
  name: fastapi
spec:
  selector:
    app: fastapi
  ports:
  - protocol: TCP
    port: 5000
    targetPort: 5000
  type: ClusterIP
```

Apply the manifest:

```bash
k apply -f manifests/01-fastapi.yaml
```

The deployment should create two ReplicaSets and two Pods. Verify that each pod reach the Running state:

```bash
k get deploy,rs -o=wide -l=app=fastapi
k get pod -o=wide -l=app=fastapi --watch
```

To test if our API the service is working, let's quickly expose the port 5000 with a ClusterIP:

```bash
k expose deploy fastapi
```

Take note of the service IP:

```bash
k get svc -o=wide -l=app=fastapi
```

Notes: When configured to use IpTables, kube-proxy uses a pseudo-random round-robin (endpoint selection) behavior to choose an endpoint. With two backend Pods, the Pod that replies to any single request is effectively random, but across many requests the distribution should be approximately 50/50.

Jump inside a temporary pod and try reach one endpoint, for example /health

```bash
k run -it --rm --image=alpine -- sh
apk add curl
curl <service-ip>:5000/health
exit
```

You should see output similar to:

```bash
/ # curl 192.168.1.4:5000/health
{"status":"ok"}/ #
Session ended, resume using 'kubectl attach sh -c sh -i -t' command when the pod is running
pod "sh" deleted
```

## Final cleanup

When you're done with the experiments, you may want to remove the container image:

```bash
docker image rm fastapi:v1
```
