---
layout: default
title: "CKAD Preparation ‚Äî Build a container image"
date: 2025-10-20
categories: [ckda, kubernetes]
author: Hiro
image: "https://supaahiro.github.io/schwifty-lab/blog-articles/20251020-ckad/article.webp"
summary: "Step-by-step guide to build a container image for a FastAPI service that exposes /health and /version endpoints. Demonstrates using a metadata.json for versioning, building and running the image, and publishing it to Kubernetes."
---

## Introduction

This article is part of an ongoing series designed to guide you through practical concepts and real-world scenarios for the Certified Kubernetes Application Developer (CKAD) exam.

In this post, we‚Äôll cover CKAD requirements within the ‚ÄúApplication Design and Build‚Äù domain:

> Define, build and modify container images

You can start from the beginning of the series here: [*CKAD Preparation ‚Äî What is Kubernetes*](https://supaahiro.github.io/schwifty-lab/blog-articles/20251019-ckad/article_EN.html).

## Prerequisites

For this exercise, you‚Äôll need Python 3.12 (or newer) and Docker 28 (or newer) to build the container image.

On Windows, you can download and install Python from the official releases page:
üëâ [Download Python for Windows](https://www.python.org/downloads/windows/).

On Linux, if you use `apt`, run:

```bash
sudo apt update
sudo apt install python3
```

If you use `yum` as your package manager, run:

```bash
sudo yum update -y
sudo yum install -y yum-utils
sudo yum install -y python3
```

Alternatively, you can install Python by compiling it from source:

```bash
sudo apt install build-essential zlib1g-dev libncurses5-dev libgdbm-dev libnss3-dev \
libssl-dev libreadline-dev libffi-dev libsqlite3-dev libbz2-dev liblzma-dev
wget https://www.python.org/ftp/python/3.12.11/Python-3.12.11.tgz
tar -zxvf Python-3.12.11.tgz
cd Python-3.12.11/
./configure --enable-optimizations
make -j "$(nproc)"
sudo make altinstall
sudo ln -s /usr/local/bin/python3.12 /usr/local/bin/python

wget https://bootstrap.pypa.io/get-pip.py
python get-pip.py
sudo ln -s /usr/local/bin/pip3.12 /usr/local/bin/pip
```

Finally, we‚Äôll try publishing the image to a Kubernetes cluster. You can use Kubernetes from Docker Desktop, Minikube, or a temporary environment on [KillerCoda Playgrounds](https://killercoda.com/playgrounds).

## Getting the Resources

All manifests and examples mentioned in this post are available in the following repository:

```bash
git clone https://github.com/SupaaHiro/schwifty-lab.git
cd schwifty-lab/blog-articles/20251020-ckad
```

## Project initialization

In this demo, we‚Äôll walk through how to build a container for a simple API service that exposes both a health status and the software version.

Our project will have the following structure:

```text
src/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ main.py
‚îÇ   ‚îî‚îÄ‚îÄ metadata.json
‚îú‚îÄ‚îÄ pyproject.toml
‚îî‚îÄ‚îÄ Dockerfile
```

The `metadata.json` file is a placeholder for a file that, in a real-world scenario, would be generated by a CI pipeline ‚Äî for example using GitVersion ‚Äî when new builds are triggered on releases, merges into `develop`, and so on.

As our package manager, we‚Äôll use uv instead of pip.

```bash
pip install uv
uv --version
```

Initialize the project:

```bash
mkdir src && cd src
mkdir app
uv init
uv add fastapi uvicorn
uv lock
```

Since we don‚Äôt have a CI pipeline injecting real metadata yet, let‚Äôs create a simple placeholder:

```json
{
  "version": "1.0.0",
  "build": "local-dev",
  "commit": "0000000"
}
```

Save it as `src/app/metadata.json`.

In a CI/CD scenario, this file would typically be replaced automatically ‚Äî for example, by GitVersion or by a job writing the correct version metadata into the container build context.

## API Service Source Code

Here‚Äôs the source code for our API service that we‚Äôll run inside the container:

```python
from fastapi import FastAPI
import json
import uvicorn

app = FastAPI()

def load_metadata():
    try:
        with open("metadata.json", "r") as f:
            return json.load(f)
    except FileNotFoundError:
        return {"version": "unknown", "build": "n/a", "commit": "n/a"}

@app.get("/health")
async def health():
    return {"status": "ok"}

@app.get("/version")
async def version():
    return load_metadata()

if __name__ == "__main__":
    uvicorn.run("app:app", port=8000, reload=True)
```

Save it as `src/app/main.py`.

## Testing the API Service

Activate the virtual environment.

On Linux:
```bash
source .venv/bin/activate
which python
```

On Windows:
```bash
.venv\Scripts\activate.bat
where python
```

Try launching the app manually to verify it works:

```bash
uv run uvicorn app.main:app --reload
```

You should see output similar to:

```bash
INFO:     Will watch for changes in these directories: ['C:\\repos\\github\\schwifty-lab\\blog-articles\\20251020-ckad\\src']
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO:     Started reloader process [26020] using StatReload
INFO:     Started server process [11200]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
```

Now, call one of the service endpoints ‚Äî for example, `/health`:

```bash
curl -svk http://127.0.0.1:8000/health
```

Expected output:

```bash
*   Trying 127.0.0.1:8000...
* Connected to 127.0.0.1 (127.0.0.1) port 8000
* using HTTP/1.x
> GET /health HTTP/1.1
> Host: 127.0.0.1:8000
> User-Agent: curl/8.14.1
> Accept: */*
>
< HTTP/1.1 200 OK
< date: Sun, 19 Oct 2025 18:24:22 GMT
< server: uvicorn
< content-length: 15
< content-type: application/json
<
{"status":"ok"}* Connection #0 to host 127.0.0.1 left intact
```

# Building the Container Image

Now let‚Äôs create the **Dockerfile** ‚Äî a text file containing the instructions Docker uses to build an image.

```dockerfile
FROM python:3.12-slim
WORKDIR /app

# Install uv
RUN python -m pip install --no-cache-dir uv

# Copy project definition and lock file
COPY pyproject.toml uv.lock ./
RUN python -m uv sync --no-dev

# Copy application
COPY app/ .

# Create non-root user
RUN useradd -m appuser
USER appuser

EXPOSE 5000

# Default environment (can be overridden)
ENV UVICORN_PORT=5000

# Start API inside uv virtual environment
CMD ["uv", "run", "uvicorn", "main:app", "--host", "0.0.0.0", "--port", "5000"]
```
> A **container image** is an executable, immutable package that includes everything needed to run an application consistently across different environments.

Build the container image:

```bash
docker build -t fastapi:v1 .
```

Then, run it to verify that it works:

```bash
docker run -it --rm -p 5000:5000 fastapi:v1
```

Now try calling one of the endpoints, for example `/version`:

```bash
curl -svk http://127.0.0.1:5000/version
```

Expected output:

```bash
*   Trying 127.0.0.1:5000...
* Connected to 127.0.0.1 (127.0.0.1) port 5000
* using HTTP/1.x
> GET /version HTTP/1.1
> Host: 127.0.0.1:5000
> User-Agent: curl/8.14.1
> Accept: */*
>
< HTTP/1.1 200 OK
< date: Sun, 19 Oct 2025 18:43:43 GMT
< server: uvicorn
< content-length: 58
< content-type: application/json
<
{"version":"1.0.0","build":"local-dev","commit":"0000000"}* Connection #0 to host 127.0.0.1 left intact
```

## Publishing to Kubernetes

Now that our image builds and runs correctly, let‚Äôs deploy it to Kubernetes.

To deploy to a non-local cluster, we first need to push it to a **Container Registry** ‚Äî a repository for container images.

If you don‚Äôt already have one, create an account on [Docker Hub](https://hub.docker.com) and then log in:

```bash
docker login
```

Next, tag your image as `your-account/image-name:tag`:

```bash
docker tag fastapi:v1 <your-docker-account>/fastapi:v1
docker push <your-docker-account>/fastapi:v1
```

We‚Äôll deploy the container as a **Deployment**:

```yaml
# manifests/01-fastapi.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: fastapi
spec:
  replicas: 1
  selector:
    matchLabels:
      app: fastapi
  template:
    metadata:
      labels:
        app: fastapi
    spec:
      containers:
      - name: fastapi
        image: <your-docker-account>/fastapi:v1
        ports:
        - containerPort: 5000
```

> A **Deployment** is a Kubernetes resource that manages the lifecycle of your application‚Äôs Pods.
>   
> It ensures the desired number of replicas are always running, automatically replaces failed Pods, and allows zero-downtime updates through rolling deployments.

Apply the manifest:

```bash
k apply -f manifests/01-fastapi.yaml
```

The deployment should create two ReplicaSets, and these should create two Pods. Verify that all Pods reach the Running state:

```bash
k get deploy,rs -o=wide -l=app=fastapi
k get pod -o=wide -l=app=fastapi --watch
```

To test whether our API service works, let‚Äôs expose port `5000` using a ClusterIP service:

```bash
k expose deploy fastapi
```

Take note of the service IP:

```bash
k get svc -o=wide -l=app=fastapi
```

üß† Note:
When configured to use iptables, kube-proxy performs pseudo-random round-robin endpoint selection. With two backend Pods, the Pod responding to any given request is effectively random ‚Äî but across many requests, the distribution should be roughly 50/50.

Now, open a temporary Pod and try reaching an endpoint, for example `/health`:

```bash
k run -it --rm --image=alpine -- sh
apk add curl
curl <service-ip>:5000/health
exit
```

Expected output:

```bash
/ # curl 192.168.1.4:5000/health
{"status":"ok"}/ #
Session ended, resume using 'kubectl attach sh -c sh -i -t' command when the pod is running
pod "sh" deleted
```
## üèÅ Wrapping Up: What We‚Äôve Covered

In this article we reviewed the full lifecycle of building, running and publishing a container image for a simple API service. Key takeaways:

- What a container image is and why it‚Äôs useful: an immutable, executable package that bundles app code, runtime and dependencies.
- How to structure a small Python/FastAPI project for containerization (source layout, metadata.json for versioning).
- How to create a Dockerfile that builds the app, installs dependencies and runs the service as a non-root user.
- How to build and run the image locally with Docker, and verify endpoints (/health and /version).
- How to push an image to a container registry and deploy it to Kubernetes using a Deployment and Service.

## Final cleanup

When you‚Äôre done experimenting, you can remove the container image:

```bash
docker image rm fastapi:v1
```
