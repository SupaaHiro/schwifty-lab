# CKAD Preparation â€” Build a container image

In this article, weâ€™ll walk through how to build a container for a simple API service that exposes both a health status and the software version.

The version is read from a `metadata.json` file which, in a real-world scenario, could be generated by your CI pipeline â€” for example using GitVersion â€” when new builds are triggered on releases, merges into `develop`, and so on.

Our project will have the following structure:

```text
src/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ main.py
â”‚   â””â”€â”€ metadata.json
â”œâ”€â”€ pyproject.toml
â””â”€â”€ Dockerfile
```

## Prerequisites

For this exercise, youâ€™ll need Python 3.12 (or newer) and Docker 28 (or newer) to build the container image.

On Windows, you can download and install Python from the official releases page:
ðŸ‘‰ [Download Python for Windows](https://www.python.org/downloads/windows/).

On Linux, if you use `apt`, run:

```bash
sudo apt update
sudo apt install python3
```

If you use `yum` as your package manager, run:

```bash
sudo yum update -y
sudo yum install -y yum-utils
sudo yum install -y python3
```

Alternatively, if youâ€™re feeling adventurous, you can install Python by compiling it from source:

```bash
sudo apt install build-essential zlib1g-dev libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev libsqlite3-dev libbz2-dev liblzma-dev
wget https://www.python.org/ftp/python/3.12.11/Python-3.12.11.tgz
tar -zxvf Python-3.12.11.tgz
cd Python-3.12.11/
./configure --enable-optimizations
make -j "$(nproc)"
sudo make altinstall
sudo ln -s /usr/local/bin/python3.12 /usr/local/bin/python

wget https://bootstrap.pypa.io/get-pip.py
python get-pip.py
sudo ln -s /usr/local/bin/pip3.12 /usr/local/bin/pip
```

Finally, weâ€™ll try publishing the image to a Kubernetes cluster. You can use Kubernetes from Docker Desktop, Minikube, or a temporary environment on [KillerCoda Playgrounds](https://killercoda.com/playgrounds).

## Getting the Resources

All manifests and examples mentioned in this post are available in the following repository:

```bash
git clone https://github.com/SupaaHiro/schwifty-lab.git
cd schwifty-lab/blog-articles/20251020-ckad
```

## Project initialization

As our package manager, weâ€™ll use uv instead of pip.

```bash
pip install uv
uv --version
```

Initialize the project:

```bash
mkdir src && cd src
mkdir app
uv init
uv add fastapi uvicorn
uv lock
```

Since we donâ€™t have a CI pipeline injecting real metadata yet, letâ€™s create a simple placeholder:

```json
{
  "version": "1.0.0",
  "build": "local-dev",
  "commit": "0000000"
}
```

Save it as `src/app/metadata.json`.

In a CI/CD scenario, this file would typically be replaced automatically â€” for example, by GitVersion or by a job writing the correct version metadata into the container build context.

## API Service Source Code

Hereâ€™s the source code for our API service that weâ€™ll run inside the container:

```python
from fastapi import FastAPI
import json
import uvicorn

app = FastAPI()

def load_metadata():
    try:
        with open("metadata.json", "r") as f:
            return json.load(f)
    except FileNotFoundError:
        return {"version": "unknown", "build": "n/a", "commit": "n/a"}

@app.get("/health")
async def health():
    return {"status": "ok"}

@app.get("/version")
async def version():
    return load_metadata()

if __name__ == "__main__":
    uvicorn.run("app:app", port=8000, reload=True)
```

Save it as `src/app/main.py`.

## Testing the API Service

Activate the virtual environment.

On Linux:
```bash
source .venv/bin/activate
which python
```

On Windows:
```bash
.venv\Scripts\activate.bat
where python
```

Try launching the app manually to verify it works:

```bash
uv run uvicorn app.main:app --reload
```

You should see output similar to:

```bash
INFO:     Will watch for changes in these directories: ['C:\\repos\\github\\schwifty-lab\\blog-articles\\20251020-ckad\\src']
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO:     Started reloader process [26020] using StatReload
INFO:     Started server process [11200]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
```

Now, call one of the service endpoints â€” for example, `/health`:

```bash
curl -svk http://127.0.0.1:8000/health
```

Expected output:

```bash
*   Trying 127.0.0.1:8000...
* Connected to 127.0.0.1 (127.0.0.1) port 8000
* using HTTP/1.x
> GET /health HTTP/1.1
> Host: 127.0.0.1:8000
> User-Agent: curl/8.14.1
> Accept: */*
>
< HTTP/1.1 200 OK
< date: Sun, 19 Oct 2025 18:24:22 GMT
< server: uvicorn
< content-length: 15
< content-type: application/json
<
{"status":"ok"}* Connection #0 to host 127.0.0.1 left intact
```

# Building the Container Image

Now letâ€™s create the **Dockerfile** â€” a simple text file containing the instructions Docker uses to build an image.

```dockerfile
FROM python:3.12-slim
WORKDIR /app

# Install uv
RUN python -m pip install --no-cache-dir uv

# Copy project definition and lock file
COPY pyproject.toml uv.lock ./
RUN python -m uv sync --no-dev

# Copy application
COPY app/ .

# Create non-root user
RUN useradd -m appuser
USER appuser

EXPOSE 5000

# Default environment (can be overridden)
ENV UVICORN_PORT=5000

# Start API inside uv virtual environment
CMD ["uv", "run", "uvicorn", "main:app", "--host", "0.0.0.0", "--port", "5000"]
```

> [!NOTE]
> What is a container?
>
> A **container image** is an executable, immutable package that includes everything needed to run an application consistently across different environments.

Build the container image:

```bash
docker build -t fastapi:v1 .
```

Then, run it to verify that it works:

```bash
docker run -it --rm -p 5000:5000 fastapi:v1
```

Now try calling one of the endpoints, for example `/version`:

```bash
curl -svk http://127.0.0.1:5000/version
```

Expected output:

```bash
*   Trying 127.0.0.1:5000...
* Connected to 127.0.0.1 (127.0.0.1) port 5000
* using HTTP/1.x
> GET /version HTTP/1.1
> Host: 127.0.0.1:5000
> User-Agent: curl/8.14.1
> Accept: */*
>
< HTTP/1.1 200 OK
< date: Sun, 19 Oct 2025 18:43:43 GMT
< server: uvicorn
< content-length: 58
< content-type: application/json
<
{"version":"1.0.0","build":"local-dev","commit":"0000000"}* Connection #0 to host 127.0.0.1 left intact
```

## Publishing to Kubernetes

Now that our image builds and runs correctly, letâ€™s deploy it to Kubernetes.
To deploy to a non-local cluster, we first need to push it to a **Container Registry** â€” a repository for container images.

If you donâ€™t already have one, create an account on [Docker Hub](https://hub.docker.com) and then log in:

```bash
docker login
```

Next, tag your image as `your-account/image-name:tag`:

```bash
docker tag fastapi:v1 <your-docker-account>/fastapi:v1
docker push <your-docker-account>/fastapi:v1
```

Weâ€™ll deploy the container as a **Deployment**:

```yaml
# manifests/01-fastapi.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: fastapi
spec:
  replicas: 1
  selector:
    matchLabels:
      app: fastapi
  template:
    metadata:
      labels:
        app: fastapi
    spec:
      containers:
      - name: fastapi
        image: <your-docker-account>/fastapi:v1
        ports:
        - containerPort: 5000
```

> [!NOTE]
> What is a Deployment?
> 
> A **Deployment** is a Kubernetes resource that manages the lifecycle of your applicationâ€™s Pods.
>   
> It ensures the desired number of replicas are always running, automatically replaces failed Pods, and allows zero-downtime updates through rolling deployments.

Apply the manifest:

```bash
k apply -f manifests/01-fastapi.yaml
```

The deployment should create two ReplicaSets and two Pods. Verify that all Pods reach the Running state:

```bash
k get deploy,rs -o=wide -l=app=fastapi
k get pod -o=wide -l=app=fastapi --watch
```

To test whether our API service works, letâ€™s expose port `5000` using a ClusterIP service:

```bash
k expose deploy fastapi
```

Take note of the service IP:

```bash
k get svc -o=wide -l=app=fastapi
```

ðŸ§  Note:
When configured to use iptables, kube-proxy performs pseudo-random round-robin endpoint selection. With two backend Pods, the Pod responding to any given request is effectively random â€” but across many requests, the distribution should be roughly 50/50.

Now, open a temporary Pod and try reaching an endpoint, for example `/health`:

```bash
k run -it --rm --image=alpine -- sh
apk add curl
curl <service-ip>:5000/health
exit
```

Expected output:

```bash
/ # curl 192.168.1.4:5000/health
{"status":"ok"}/ #
Session ended, resume using 'kubectl attach sh -c sh -i -t' command when the pod is running
pod "sh" deleted
```

## Final cleanup

When youâ€™re done experimenting, you can remove the container image:

```bash
docker image rm fastapi:v1
```
